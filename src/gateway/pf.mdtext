## The <a href="http://www.openbsd.org">OpenBSD</a> Packet Filter 

<div class="toc">

Table of Contents

<ul>
	<li><a href="#confirm">Confirmation</a></li>
    <li><a href="#policy">Firewall Policy</a></li>
	<li><a href="#verify">Verifiability</a></li>
    <li><a href="#notes">Side Notes</a></li>
    <li><a href="#reference">References</a></li>
</ul>

</div>

Building an OpenBSD Firewall is based on the Packet Filter Engine $!manpage("pf",4)!$  and 
is well documented in manpages, with additional project documentation
in the [PF FAQ](http://www.openbsd.org/faq/pf/index.html).

These notes assist in the maintenance, monitoring of PF.

At this point, do not be ashamed to purchase a book on Packet Filtering and
OpenBSD. You can learn from your own mistakes, and make your own investigations
on the Internet and on these pages, but you can also save yourself a lot
of grief by buying the knowledge of those who've spent some quality effort
to document real-life use of PF, with experience in diverse applications.

What ever you do from here, you really do need to read a series of free resources
published by Daniel Hartmeier on Undeadly:

-	[PF: Testing your Firewall](http://undeadly.org/cgi?action=article&sid=20060928081238), 
-	[Firewall Rule Optimization](http://undeadly.org/cgi?action=article&sid=20060927091645), 
-	[Firewall Management](http://undeadly.org/cgi?action=article&sid=20060929080943)

<div class="image">
    $!Image("fw/fw_traffic_flow.png", title="Firewall - Traffic Flow")!$
</div>

<blockquote>
<p>Packet Filter (from here on referred to as PF) is OpenBSD's system 
for filtering TCP/IP traffic and doing Network Address Translation. 
PF is also capable of normalizing and conditioning TCP/IP traffic and 
providing bandwidth control and packet prioritization. PF has been a 
part of the GENERIC OpenBSD kernel since OpenBSD 3.0. Previous 
OpenBSD releases used a different firewall/NAT package which is 
no longer supported. </p>

-- <a href="http://www.openbsd.org/faq/pf/index.html">PF FAQ</a>
</blockquote>

### <a name="confirm">Confirmation</a>

To verify that PF is operational, use pfctl such as:

<pre class="command-line">
sudo pfctl -s info
</pre>

<pre class="screen-output">
Status: Enabled for 453 days 00:57:16         Debug: Urgent

...
</pre>

### <a name="policy">Firewall Policy</a>

To verify our firewalls performance, is to presume a clear understanding/definition of what is
acceptable behaviour, and what is not. Vagaries makes verification exponentially more
difficult if not impossible to define conformance ?

<blockquote>
<h4>A well-defined filtering policy</h4>

<p>The filtering policy is an informal specification of what the firewall is supposed to do. 
A ruleset, like a program, is the implementation of a specification, a set of formal instructions 
executed by a machine. In order to write a program, you need to define what it should do.
</p>

Daniel Hartmeier's <a href="http://undeadly.org/cgi?action=article&sid=20060928081238">PF: Testing your Firewall</a>
</blockquote>

In our context the Policy document serves as a communications tool:

1. Between Firewall Administrators and the business, outlining in a broad brush 
    of how the firewalls will persist as a gateway between the organisation and external IT services.
2.  Between the design team and testers, implementors, maintainers of specifics to be addressed by the Firewall.
3.  Between the IT organisation and auditors.
4.  For the Change Management Process.

In practise, our Firewall Policy document is divided into these major groups:

#### Broad Description

As a communications tool, the Policy Document will many times sit in front 
of non-technical people with little or no technology background, let alone
understanding of what a Firewall does.

A brief, broad description, at the beginning of each of our Policy Documents
draws a generalised overview of the the function and purpose of a firewall
for the benefit of non-technical staff.

The description covers the non-technical overview of a firewall, as well
as outlining the major categories of source and destination traffic.

For example;

<blockquote>
<p>blurb ... blurb</p>

<p>By default, our Firewall blocks all traffic not explicitly approved.</p>

<p>The below Policies specify which IP Traffic is allowed through the 
firewall, and the rationale for it's approval.</p>
</blockquote>

#### Policies

A brief description of the general policies in place, under which are specific 
descriptions of which IP Traffic flow is approved, acceptable.

As per Daniel's recommendations above, the text is descriptive and sufficient to
develop firewall rulesets, without being a full syntax. 

For example:

<blockquote>
<p>Local Area Network Interface (tag: LAN_DMZ)<p>
<p>Policy: Allow from Exchange Server to MX Proxies on tcp on port smtp</p>
<p>Rationale: Allow smtp (mail submission) to the MX Proxy from the Corporate
Exchange Server. This service is to allow our e-mail out.</p>
</blockquote>

#### Implementation - Production Ruleset

Required for the Change Management Process.

The actual ruleset, periodically downloaded from the live server.

<pre class="config-file">
pass in on $lan_if inet proto tcp from <ms_exchange> to <mx_proxies> port smtp
</pre>

#### Standard Change

There should be a list of specific operational activities that should be pre-approved changes for the
Firewall Rules. 

For instance:

Where you have list of approved destination sites, encapsulated in your rules as a table, it may be
appropriate to pre-approve additions to the table (using another mechanism other than the
change committee(s).)

A specific example where the above occurred for us, is the addition of redundant services.
When we decided to add an extra MX Proxy to our infrastructure, we added a new host
which we allowed through the Firewall by adding the new IP to the Firewall without needing
to pass the document through the Change Committees.

### <a name="verify">Verifiability</a>

These notes evolve our experience evolving a deployment that is verifiable for policy and
performance compliance. 

### <a name="notes">Side Notes</a>:

-   *keep state* became default rule behavior circa release 4.1
-   nat/rdr/binat rules are evaluated before pass rules (up to 4.6)
-   4.7+ nat/rdr/binat rules are now 'actions' on regular rules, separate execution no longer exists.

### <a name="reference">References</a>:

-   The [Packet Filter FAQ](http://www.openbsd.org/faq/pf/index.html) always documents RELEASE
-	Daniel Hartmeier's articles on PF @ Undeadly 
	[PF: Testing your Firewall](http://undeadly.org/cgi?action=article&sid=20060928081238) | 
	[Firewall Rule Optimization](http://undeadly.org/cgi?action=article&sid=20060927091645) |
	[Firewall Management](http://undeadly.org/cgi?action=article&sid=20060929080943)
-   [Book: Building Firewalls with OpenBSD and PF, 2nd ed.](http://www.amazon.com/Building-Firewalls-OpenBSD-PF-2nd/product-reviews/8391665119)
-	[Book: Absolute OpenBSD: UNIX for the Practical Paranoid](http://www.amazon.com/Absolute-OpenBSD-UNIX-Practical-Paranoid/dp/1886411999/ref=cm_cr_pr_sims_t)